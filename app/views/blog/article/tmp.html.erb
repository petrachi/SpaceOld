<%= container do %>
	<%= row do %>
		<%= three_span :element => :sidebar do %>
			1
		<% end %>

		<%= nine_span :element => :article do %>
			
			
			
			
			
			<%
				
					









				# eléments de base
				#normalement ouvert
				def switch_no p = true, *i
					{
						[false, false] => false,
						[false, true] => false,
						[true, false] => false,
						[true, true] => true
					}[[p, *i]]
				end
				
				#normalement closed
				def switch_nc p = true, *i 
					{
						[false, false] => false,
						[false, true] => false,
						[true, false] => true,
						[true, true] => false
					}[[p, *i]]
				end
				
				def split p = true
					{
						false => [false]*2
					}[p]
				end
				
				def combine *p
					p ||= Array.new 2, true
					
					{
						[false, false] => false,
						[false, true] => true,
						[true, false] => true,
						[true, true] => true
					}[p]
				end
				
				
				
				# portes logiques
				def yes p, i
					switch_no p, i
				end
				
				def no p, i
					switch_nc p, i
				end
				
				def d_and p, *i
					f = switch_no p, i[0]
					switch_no f, i[1]
				end
				
				def d_or p, *i
					f = Array.new 2
					
					f[0] = switch_no p, i[0]
					f[1] = switch_no p, i[1]
					combine *f
				end
				
				def not_and p, *i
					f = Array.new 2
					
					f[0] = switch_nc p, i[0]
					f[1] = switch_nc p, i[1]
					combine *f
				end
				
				def not_or p, *i
					f = switch_nc p, i[0]
					switch_nc f, i[1]
				end
				
				def xor p, *i
					f = Array.new 2
					
					f[0] = switch_nc p, i[0]
					f[0] = switch_no f[0], i[1]
					
					f[1] = switch_no p, i[0]
					f[1] = switch_nc f[1], i[1]
					
					combine *f
				end
				
				
				
				# additionneurs
				def half_adder *i
					f = Array.new 2
					
					o = xor true, *i
					r = d_and true, *i
					
					return o, r
				end
				
				def adder *i
					tmp_o, tmp_r1 = half_adder i[0], i[1]
					o, tmp_r2 = half_adder tmp_o, i[2]
					
					r = d_or true, tmp_r1, tmp_r2
					
					return o, r
				end
				
				def parallel_adder_4bit *i
					o = Array.new 4
					
					#premier nombre 4 bit == i[0..3]
					#second nombre 4 bit == i[4..7]
					#premiere retenue == i[8]
										
					o[3], r = adder i[3], i[7], i[8]
					o[2], r = adder i[2], i[6], r
					o[1], r = adder i[1], i[5], r
					o[0], r = adder i[0], i[4], r 
					
					return r, *o
				end
			%>
			
			
			<%
			#truc d'affichages
			def to_4bit i
				("%04d" % i.to_s(2)).split(//).map{ |x| x == "1" }
			end
			
			def from_4bit i
				i.map{|x| x ? "1" : "0"}.join.to_i(2)
			end
			%>
			
			<h3>or</h3>
			true true false false<br/>
			<%= d_or true, true, true %>
			<%= d_or true, true, false %>
			<%= d_or true, false, false %>
			<%= d_or false, true, true %>
			
			<hr/>
			
			<h3>half adder</h3>
			[false, false] [true, false] [false, true]<br/>
			<%= half_adder(false, false).inspect %>
			<%= half_adder(false, true).inspect %>
			<%= half_adder(true, true).inspect %>
			
			<hr/>
			
			<h3>adder</h3>
			[false, false] [true, false] [false, true] [true, false] [false, true] [true, true]<br/>
			<%= adder(false, false, false).inspect %>
			<%= adder(false, true, false).inspect %>
			<%= adder(true, true, false).inspect %>
			<%= adder(true, false, false).inspect %>
			<%= adder(true, false, true).inspect %>
			<%= adder(true, true, true).inspect %>
			
			<hr/>
			
			<h3>parallel adder 4bit</h3>
			<%	lookup = Hash.new{ |h, k| h[k] = to_4bit k }
				r_lookup = Hash.new{ |h, k| h[k] = from_4bit k }# need une fonction rfetch pour les hash -> idée pour r_extend
			
				setup_2 = (lookup[1] + lookup[1]).flatten << false
				setup_5 = (lookup[2] + lookup[3]).flatten << false
				setup_7 = (lookup[2] + lookup[5]).flatten << false
				setup_15 = (lookup[9] + lookup[6]).flatten << false
				setup_24 = (lookup[15] + lookup[9]).flatten << false
				setup_31 = (lookup[15] + lookup[15]).flatten << true
				
			%>
			
			2 5 7 15 24 31<br/>
			<%= r_lookup[parallel_adder_4bit(*setup_2)] %>
			<%= r_lookup[parallel_adder_4bit(*setup_5)] %>
			<%= r_lookup[parallel_adder_4bit(*setup_7)] %>
			<%= r_lookup[parallel_adder_4bit(*setup_15)] %>
			<%= r_lookup[parallel_adder_4bit(*setup_24)] %>
			<%= r_lookup[parallel_adder_4bit(*setup_31)] %>
			
			
			
			<hr/>
			<h1>Using class</h1>
			<hr/>
			
			<h3>parallel adder 4bit</h3>
			<%	lookup = Hash.new{ |h, k| h[k] = to_4bit k }
				r_lookup = Hash.new{ |h, k| h[k] = from_4bit k }# need une fonction rfetch pour les hash -> idée pour r_extend
			
				setup_2 = (lookup[1] + lookup[1]).flatten << false
				setup_5 = (lookup[2] + lookup[3]).flatten << false
				setup_7 = (lookup[2] + lookup[5]).flatten << false
				setup_15 = (lookup[9] + lookup[6]).flatten << false
				setup_24 = (lookup[15] + lookup[9]).flatten << false
				setup_31 = (lookup[15] + lookup[15]).flatten << true
				
			%>
			
			2 5 7 15 24 31<br/>
			<%#= r_lookup[Adder.new.parallel_adder_4bit(*setup_2)] %>
			<%#= r_lookup[Adder.new.parallel_adder_4bit(*setup_5)] %>
			<%#= r_lookup[Adder.new.parallel_adder_4bit(*setup_7)] %>
			<%#= r_lookup[Adder.new.parallel_adder_4bit(*setup_15)] %>
			<%#= r_lookup[Adder.new.parallel_adder_4bit(*setup_24)] %>
			<%#= r_lookup[Adder.new.parallel_adder_4bit(*setup_31)] %>
			
			
			
			
			
			
			
			
			
			
			
			<hr/>
			<hr/>
			
			<i>Le Hill-Climbing, c'est un algorithme génétique dégénéré. Un algorithme génétique, on verra ce que c'est, et comment ça dégénére.</i>
			
			<h2>Hill-Climbing</h2>
			
			<p>
				Bienvenue aux tous-petits et aux grandes personne qui les accompagnent.<br/>
				Aujourd'hui dans notre spectacle, nous allons parler d'un poulpe, d'aléatoire, de mutation et d'évolution. Un programme complet qui ravira les esprits de 7 à 77ans.
			</p>
			
			<h3>Introduction à la génétique</h3>
			
			<p>
				En informatique, il y les algorithmes, et dans les algorithmes, il y a les algorithmes génétiques.<br/>
				Pour résumer ce que j'en sais, un algorithme génétique va tenter d'apporter une solution à un problème de la façon suivante : 
			</p>
			
			<ul>
				<li>
					D'abord, on va créer une population initiale. La population, c'est un ensemble d'individus, un individus, c'est une solution possible au problème. Chaque individu est généré aléatoirement à partir d'un ensemble de gênes.
				</li>
				<li>
					Ensuite, on va se charger d'évaluer chaque individu par rapport au problème. Si l'individu apporte une réponse satisfaisante, il obtiendra un bon score, sinon, un score inférieur.
				</li>
				<li>
					En fonction du score de chaque individu, on va sélectionner les meilleurs parmi toute la population, et les faire se reproduire entre eux. Cette reproduction donnera une nouvelle génération d'individus, qui devraient globalement apporter une meilleure solution au problème initial.
				</li>
				<li>
					On pourra éventuellement faire "muter" quelques individus de la nouvelle génération, afin d'apporter une diversité génétique supplémentaire.
				</li>
				<li>
					On pourra répéter l'opération autant de fois possible, ce qui nous permettra à chaque nouvelle génération de nous rapprocher d'une solution optimale.
				</li>
			</ul>
			
			<p>
				Il est important de noter que le but d'un algorithme génétique est d'arriver à une solution acceptable, et non parfaite. On pourrait imaginer des mise en oeuvre de ce type d'algorithmes dans la création d'une IA, ou pour du ciblage publicitaire.
			</p>
			
			<p>
				Si vous vous interressez aux algorithmes génétiques, je vous invite à lire l'excelente série "alogrithmes génétiques démistyfiés" sur ce blog (#mettre lien), qui m'a moi-même fait découvrir le sujet.
			</p>
			
			<h3>De la génétique au poulpe</h3>
			
			<p>
				Cette fois, nous avons une image de poulpe, et nous allons mettre en oeuvre un algorithme génétique un peu spécial, dit de hill-climbing, afin de retrouver l'image du poulpe, à partir d'une image crée aléatoirement.
			</p>
			
			# mettre image aléatoire => image poulpe
			
			<p>
				Comme je le dis, l'algorithme génétique utilisé ici est spécial, car il ne prendra ni population, ni reproduction, uniquement la mutation. C'est du hill-climbing. Le principe ici, nous allons générer une population d'un seul individu, le faire muter, puis sélectionner le meilleur score entre l'individu original et sa mutation.
			</p>
			
			<p>
				Ce genre d'algorithme de hill-climbing sont souvent utilisés afin de tester les fonctions d'évaluations et de mutation, avant de mettre en place un algorithme génétique complet.
			</p>
			
			<h3>Manipulation d'images</h3>
			
			<p>
				Afin de créer et de comparer des images, j'avais d'abord pensé utiliser un format binaire, ou en base 64. Mais l'encodage d'un PNG est d'une complexité qui ne permet pas un apprentissage rapide. Aussi, j'ai choisis d'utiliser une gem disponible en rails : chunky-png.
			</p>
			
			# mettre code / image essai infructueux
			
			<p>
				Chunky-png permet facilement de créer ou manipuler des PNG. Je vous fait une démo :  
			</p>
			
			# mettre code / image d'une ouverture de fichier + création de fichier
			
			<h3>De l'aléatoire à la mutation, au poulpe</h3>
			
			<p>
				Enfin, nous avons tous les outils pour réaliser notre petite expérience. Nous allons commencer par déclarer la valeur cherchée (image originale du poulpe), puis créer notre premier individu.
			</p>
			
			# mettre code creation img
			
			<p>
				Ensuite nous allons faire muter cette image. Il s'agira de sélectionner quelques pixels aléatoirement, et de leur assigner une nouvelle valeur.
			</p>
			
			# mettre code mutation img
			
			<p>
				Puis, nous pouvons évaluer ces deux individus, afin de définir le meilleur. Le score d'un individu correspondra au nombre de pixels identiques à l'image originale.
			</p>
			
			# mettre code évaluation
			
			<p>Et voilà ce que ça donne pour 600 générations : </p>
			
			# mettre sur 2 col : N°gen / score(en %) - image
			# toutes les 150 gen
			
			<h3>Conclusion</h3>
			
			<p>
				Je trouve assez impressionnant de réussir à recréer une image, sans vraiment s'intéresser à la manière dont elle est construite. Tout ce qui nous intéresse ici, c'est de savoir si l'individu crée est proche ou non de la solution. La manière dont cet individu à été fabriqué nous est totalement étrangère, et c'est ce que je trouve un peu magique dans ces algorithmes génétiques.
			</p>
			
			<p>
				Pendant que je faisait ce bout de code, j'ai beaucoup pensé aux différentes applications, et j'ai repensé à la problématique de répartition uniforme des point à la surface d'une sphère, qui nous avait posé misère sur une expérience précédente (# mettre lien). Peut-être verrons-nous bientôt une "sphére génétique" ?
			</p>
			
			<p>
				Bisous bisous, c'est la fin.
			</p>
			
		<% end %>
	<% end %>
<% end %>


