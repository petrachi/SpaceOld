<%= container do %>
	<%= row do %>
		<%= three_span :element => :sidebar do %>
			1
		<% end %>

		<%= nine_span :element => :article do %>
		
			<h2>Blocks, Procs, Lambda. Que sait-on d'eux ?</h2>
		
			<p>
				Ils ont des noms abrutissants : blocks, procs et lambda. Ils permettent au développeur de passer du code en paramètre d'une fonction. Ce sont une composante fondamentale du code ruby le plus évolué. Pour certains, ce sont des compagnons méconnus. Mais que savons-nous vraiment à propos des blocks, des procs, et des lambda.
			</p>
			
			<h3>Entrée dans l'univers</h3>
			
			<p>
				Block, proc et lambda sont trois noms qui désignent la même chose : un bout de code définit anonymement. C'est à dire qu'il n'est lié à aucune déclaration, dans aucun contexte.
			</p>
			
			<p>
				Les développeurs ruby et rails utilisent souvent des blocks, plusieurs fonction, comme le <i>Array#each</i> <code>Array#each</code> <%= CodeRay.scan("Array#each", :ruby).span.html_safe %> prennent un block en paramètre. Mais plus rare sont ceux qui pensent aux blocks lorsqu'il s'agit de créer leurs propres fonctions.
			</p>
		
			<h3>
				Commencer avec les blocks
			</h3>
		
			<p>
				Voici un exemple d'une fonction simple, qui utilise un block
			</p>
		
			<%= coderay :lang => :ruby do %>
	def simple
		p "Start of my very simple function"
		yield
		p "End of my very simple function"
	end

	?> simple{ p "I'm alive !" }
	=> "Start of my very simple function"
	"I'm alive !"
	"End of my very simple function"
			<% end %>
		
			<p>
				L'instruction <code>yield</code> <%= CodeRay.scan("yield", :ruby).span.html_safe %> indique à la fonction d'exécuter le code passé en paramètre, lors de l'appel.
			</p>
			
			<p>
				Notez que la syntaxe peut aussi varier, afin de bénéficier d'une déclaration plus explicite.
			</p>
			
			<%= coderay :lang => :ruby do %>
	def simple &block
		p "Start of my very simple function"
		block.call
		p "End of my very simple function"
	end

	?> simple{ p "I'm alive !" }
	=> "Start of my very simple function"
	"I'm alive !"
	"End of my very simple function"
			<% end %>
			
			<h3>
				Suite ... le niveau 1
			</h3>
		
			<%= container do %>
	    		<%= row :nested => true do %>
		    		<%= four_span :append => 1 do %>
		    			<h4>Block optionnel - Tu vas dessus ou je vais dessus ?</h4>
						
		    			<%= coderay :lang => :ruby do %>
	def optional
		p "In my optionnal block function"
		if block_given?
			yield
		else
			p "No block given, so sad :("
		end
	end

	?> optional{ p "I'm alive" }
	=> "In my optionnal block function"
	"I'm alive"

	?> optional
	=> "In my optionnal block function"
	"No block given, so sad :("
						<% end %>
						
						<p>
							L'appel à <code>block_given?</code> permet de s'assurer de la présence d'un block à l'appel de la fonction.
						</p>
		      		<% end %>

			      	<%= four_span do %>
			      		<h4>Des paramètres au block</h4>

			      		<%= coderay :lang => :ruby do %>
	def parameters
		p "Here, have two random numbers."
		yield rand(10), rand(50)
		p "Now say thank you!"
	end

	?> parameters { |x, y| p "#{ x }, #{ y }" }
	=> "Here, have two random numbers."
	"8, 21"
	"Now say thank you!"
			   			<% end %>
						
						<p>
							Je donne à l'appel de la fonction des valeurs qui seront traitées dans le block, sans savoir ce que le développeur décidera d'en faire. C'est ici que ce joue la magie d'un <code>Array#each</code> par exemple.
						</p>
			   		<% end %>
			   	<% end %>
		  	<% end %>
		
			<h3>
				La fin de l'apprentissage
			</h3>
		
			<p>
				Il ne me reste qu'une seule chose à vous dire.
			</p>
	
			<%= coderay :lang => :ruby do %>
	def arity &block
		p "Arity function has begun"
		case block.arity
		when 1 then yield "one"
		when 2 then yield "one", "two"
		when 3 then yield "one", "two", "three"
		end
		p "Arity has ended"
	end

	?> arity{}
	=> "Arity function has begun"
	"Arity has ended"

	?> arity{ |x| p x }
	=> "Arity function has begun"
	"one"
	"Arity has ended"

	?> arity{ |x, y| p x, y }
	=> "Arity function has begun"
	"one"
	"two"
	"Arity has ended"

	?> arity{ |x, y, z| p x, y, z }
	=> "Arity function has begun"
	"one"
	"two"
	"three"
	"Arity has ended"
			<% end %>

			<p>
				La méthode <code>Proc#arity</code> permet de connaitre le nombre d'argument demandé lors de l'appel. Vous pourrez adapter le code de votre fonction afin de permettre différentes utilisations (utiliser un <code>Array</code> ou un <code>Hash</code> par exemple)
			</p>
		
			<h3>
				IRL
			</h3>
		
			<p>
				Et dans la vraie vie, on s'en sert quand de blocks ? Pricipalement lorsqu'il s'agit d'itérateurs (each, map, in_groups_of), ou de templates (link_to, content_for)
			</p>
			
			<%= container do %>
	    		<%= row :nested => true do %>
		    		<%= four_span :append => 1 do %>
						<h3>
							Un itérateur inutile
						</h3>
						
						<%= coderay :lang => :ruby do %>
	class Array
		def each_but_not_all range
			range.each do |i|
				yield self[i]
			end
		end
	end

	?> array = [1, 2, 3, 4, 5]
	=> [1, 2, 3, 4, 5]

	?> array.each_but_not_all (1..3) { |x| p x }
	=> 2
	3
	4
						<% end %>
					<% end %>
					
					<%= four_span do %>
						<h3>
							Une template inutile
						</h3>
						
						<p>
							<%= coderay :lang => :ruby do %>
					def my_box_tag &block
						"<div>" << yield << "</div>"
					end
							<% end %>
						</p>
					<% end %>
				<% end %>
			<% end %>
			
		
			<h3>
				Conclusion
			</h3>
		
			<p>
				Les blocks, c'est bien. C'est surtout un bon moyen de s'amuser et de rendre du code générique (ou bien, de rendre une partie du code spécifique).
			</p>
			
			<p>
				Je n'ai pas parlé de la différence entre proc et lambda.
			</p>
			
			<p>
				La prochaine fois, on parlera probablement d'un article que j'ai encore à lire : "Programming from nothing", et qui utilise uniquement les blocks pour recréer tout le langage.<br/>
				Je vous fait des bisous !
			</p>
		
		<% end %>
	<% end %>
<% end %>
