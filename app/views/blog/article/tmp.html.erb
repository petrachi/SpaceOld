<%= container_tag do %>
	<%= row_tag do %>
		<%= col_3_tag :element => :sidebar do %>
			1
		<% end %>

		<%= col_9_tag :element => :article do %>
			
			
			<%= @article.title %>
			
			<hr/>
			
			<%= decorate Blog::Article.last do |article| %>
				<%= article.title %>
			<% end %>
			
			<hr/>
			<hr/>
			<hr/>
			
			
			
			<i>On prend deux couleurs, on les mixe, et on obtient un dégradé parfaitement génial (mais le code tout à fait dégueulasse).</i>
			
			<h2>Color Blender</h2>
			
			<p>
				Salut les p'tit amis,<br/>
				Aujourd'hui on va contruire un algorithme de création de dégradé, ou 'color blender', en ruby, parceque c'est fun !
			</p>
			
			<h3>Format de couleur</h3>
			
			<p>
				On va utiliser deux formats de couleurs pour notre algorithme, rgb pour manipuler les valeurs, parceque manipuler des décimales c'est quand même plus sympa, et puis de l'hexa aussi, parceque je trouve ça plus joli. À titre d'exemple, le rouge utilise sur ce site donne en rgb quelquechose comme (182, 43, 43), et en hexa #b62b2b.<br/>
				Tout ça nous donner l'occasion de travailler sur deux petites fonctions de conversion !
			</p>
			
			<%= coderay do %>
def hex_to_rgb hex
	hex =~ /#(..)(..)(..)/
	{r: $1.hex, v: $2.hex, b: $3.hex}
end

def rgb_to_hex rgb
	"##{"%02x" % rgb[:r]}#{"%02x" % rgb[:v]}#{"%02x" % rgb[:b]}"
end
			<% end %>
			
			<h3>Color diff + pourcentages</h3>
			
			<p>
				Allez, sans transitions on rentre dans le vif du sujet, on commence par calculer la différence de valeurs entre les deux couleurs passées en paramètres (notés <%= coderay({:inline => true}, "from, to") %>).
			</p>
			
			<%= coderay do %>
def diff_color from, to
	{
		r: to[:r] - from[:r],
		v: to[:v] - from[:v],
		b: to[:b] - from[:b]
	}
end
			<% end %>
			
			<p>
				Ensuite, nous allons pouvoir progresser lentement, à partir de la première couleur, vers la seconde, en appliquant une portion donnée de la différence entre les deux couleurs.
			</p>
			
			<%= coderay do %>
def blend_color from, diff, progress
	{
		r: from[:r] + diff[:r] * progress,
		v: from[:v] + diff[:v] * progress,
		b: from[:b] + diff[:b] * progress
	}
end
			<% end %>
			
			<h3>Unification dans le blender</h3>
			
			<p>
				Nous avons toutes les composantes pour notre fonction de color blender, il suffit juste de tout mettre bout à bout : 
			</p>
			
			<%= coderay do %>
def blender from, to, steps
	blender = Array.new

	from = hex_to_rgb color_stops.shift
	to = hex_to_rgb color_stops.first

	diff = diff_color from, to

	steps.times do |i|
		progress = percent i, steps

		blended = blend_color from, diff, progress
		blender << rgb_to_hex(blended)
	end

	blender
end
			<% end %>
			
			<p>
				Si on fait un test rapide avec <%= coderay({:inline => true}, "blender '#A21111', '#D3A80D', 168") %>
			</p>
			
			<%= erb Blog::Experience.tagged(:color_clock).run(:only_blender) %>
			
			<h3>Color stops</h3>
			
			<p>
				Avant de conclure, je vous montre une version améliorée qui permet de chainer plusieurs couleurs en un seul appel.
			</p>
			
			<%= coderay do %>
def blender color_stops, steps
	blender = Array.new

	begin
		from = hex_to_rgb color_stops.shift
		to = hex_to_rgb color_stops.first

		diff = diff_color from, to

		steps.times do |i|
			progress = percent i, steps

			blended = blend_color from, diff, progress

			p "progress #{progress} - #{blended}"

			blender << rgb_to_hex(blended)
		end
	end while color_stops.size > 1

	blender
end
			<% end %>
			
			<p><%= coderay({:inline => true}, "blender %w(#063186 #A21111 #D3A80D #28A528), 56") %></p>
			
			<%= erb Blog::Experience.tagged(:color_clock).run(:multiple_blender) %>
			
			<h3>Conclusion</h3>
			
			<p>
				Voilà, c'est fini, un color blender simple et rapidement réalisé.<br/>
				On pourrait bien sûr améliorer cette fonction, transformer ce code fontionnel en orienté objet, inclure la transparence, mieux gérer le nombre d'itérations en deux couleurs.
			</p>
			
			<p>
				J'ai développé cet algorithme pour l'exéprience du "color clock" (que j'avais commencé à travailler en javascript), et je l'ai aussi utilisé pour l'expérience du "genetic octopus". Pour moi, cette fonction a rempli son office.
			</p>
			
			<p>
				Allez, bisous. Filez jouer maintenant !
			</p>
			
			
			
			
			
			
		<% end %>
	<% end %>
<% end %>


