<%= container do %>
	<%= row do %>
		<%= three_span :element => :sidebar do %>
			1
		<% end %>

		<%= nine_span :element => :article do %>
			
			
			<%= @article.title %>
			
			<hr/>
			
			<%= decorate Blog::Article.last do |article| %>
				<%= article.title %>
			<% end %>
			
			<hr/>
			<hr/>
			<hr/>
			
			
			
			<i>On prend deux couleurs, on les mixe, et on obtient un dégradé parfaitement génial, avec du code tout à fait dégueulasse.</i>
			
			<h2>Color Blender</h2>
			
			<p>
				Salut les p'tit amis,<br/>
				Donc le principe ici sera de faire une fonction permettant d'assurer une transition fluide entre deux couleurs.
			</p>
			
			<h3>Format de couleur</h3>
			
			<p>
				En gros, il y a deux formats de couleurs classiques utilisés en développement informatique.<br/>
				Le format hexadécimal, où le blanc est représenté comme ceci #ffffff, et le rouge utilisé pour les boutons de ce site #b62b2b. Ou le format rgv (pour touge, vert, bleu), où le blanc fait rgb(255, 255, 255), et le rouge des boutons fait rbg(182, 43, 43).<br/>
				On peut également trouver un format hsv, pour teinte, saturation et luminosité. Mais je crois que ce format est plus souvent utilisé en photo montage qu'en programmation.
			</p>
			
			<p>
				Nous allons devoir manipuler des couleurs dans notre petit algorithme, il faut donc choisir le format le plus approprié. J'ai choisi de travailler avec le format rgb, car utiliser les valeurs numériques sont plus faciles à manipuler. Le résultat attendu devra par contre être exprimé en hexa, car ce format est plus lisible.<br/>
				À la réflexion, manipuler les couleurs avec le format hsv aurait peut-être simplifié la tâche, ar ils sépare bien toute les composantes d'une couleur, et permet donc de trouver facilement une transition fluide.
			</p>
			
			<%= coderay do %>
def hex_to_rgb hex
	hex =~ /#(..)(..)(..)/
	{r: $1.hex, v: $2.hex, b: $3.hex}
end

def rgb_to_hex rgb
	"##{"%02x" % rgb[:r]}#{"%02x" % rgb[:v]}#{"%02x" % rgb[:b]}"
end
			<% end %>
			
			<h3>Color diff + color blend</h3>
			
			<p>
				Maintenant, on va devoir apprendre à m'langer deux couleurs. Pour ça, on calculera d'abord les valeurs de différences entre les deux couleurs. C'est relativement simple.
			</p>
			
			<%= coderay do %>
def diff_color from, to
	{
		r: to[:r] - from[:r],
		v: to[:v] - from[:v],
		b: to[:b] - from[:b]
	}
end
			<% end %>
			
			<p>
				Ensuite, nous allons appliquer cette différence à partir de la couleur de base, accouplé à un pourcentage de transformation.
			</p>
			
			<%= coderay do %>
def blend_color from, diff, progress
	{
		r: from[:r] + diff[:r] * progress,
		v: from[:v] + diff[:v] * progress,
		b: from[:b] + diff[:b] * progress
	}
end
			<% end %>
			
			<h3>Réunification de toutes les composantes</h3>
			
			<p>
				Nous pouvons maintenant réunir toutes les différentes étapes de notre blender. De la conversion rgb/hex, au calcul de la différence et à la transition lente d'une couleur à l'autre.
			</p>
			
			<%= coderay do %>
def blender from, to, steps
	blender = Array.new

	from = hex_to_rgb color_stops.shift
	to = hex_to_rgb color_stops.first

	diff = diff_color from, to

	steps.times do |i|
		progress = percent i, steps

		blended = blend_color from, diff, progress
		blender << rgb_to_hex(blended)
	end

	blender
end
			<% end %>
			
			<p>
				Si on fait un test rapide avec <%= coderay({:inline => true}, "blender '#A21111', '#D3A80D', 168") %>
			</p>
			
			<%= erb Blog::Experience.tagged(:color_clock).run(:only_blender) %>
			
			<h3>Color stops</h3>
			
			<p>
				Avant de conclure, je vous présente juste une petite amélioration qui permettra de chainer les appels à l'ancien blender.
			</p>
			
			<%= coderay do %>
def blender color_stops, steps
	blender = Array.new

	begin
		from = hex_to_rgb color_stops.shift
		to = hex_to_rgb color_stops.first

		diff = diff_color from, to

		steps.times do |i|
			progress = percent i, steps

			blended = blend_color from, diff, progress

			p "progress #{progress} - #{blended}"

			blender << rgb_to_hex(blended)
		end
	end while color_stops.size > 1

	blender
end
			<% end %>
			
			<p><%= coderay({:inline => true}, "blender %w(#063186 #A21111 #D3A80D #28A528), 56") %></p>
			
			<%= erb Blog::Experience.tagged(:color_clock).run(:multiple_blender) %>
			
			<h3>Conclusion</h3>
			
			<p>
				Voilà, un color blender très simple et rapidement réalisé. On pourrait améliorer largement cette fonction, pour inclure la transparence d'abord. Puis améliorer la gestion des <%= coderay({:inline => true}, "color_stops") %>, qui est très statique aujourd'hui.
			</p>
			
			<p>
				En dehors de ces améliorations possibles, l'algorithme fonctionne suffisamment bien. Je l'ai mis en place pour l'expérience du "color clock", et il remplit son rôle. J'avais commencé par le faire en javascript, mais j'avoue être bien plus à l'aise en ruby.
			</p>
			
			<p>
				Allez, bisous. Filez jouer maintenant !
			</p>
			
			
			
			
			
			
			
			
			
			
			<hr/>
			<hr/>
			<hr/>
			<hr/>
			<hr/>
			<hr/>
			<hr/>
			<hr/>
			<hr/>
			<hr/>
			<hr/>
			<hr/>
			
			
			
			
			
			
			<i>Mince, j'ai pas un IDE chouettos qui peut m'envoyer directement à la définition d'une méthode. Je suis bloqué ! Si seulement le SPACE BLOG avait un protip à ce sujet ...</i>
			
			<h2>Method location</h2>
			
			<p>
				Salut tout le monde ! Vous êtes en forme aujourd'hui ?<br/>
				C'est important de poser la question, parce qu'on va envoyer la sauce pas plus tard que maintenant. Trouver facilement le fichier et la ligne où est définie une méthode, c'est possible ! Et c'est parfois utile, aussi.
			</p>
			
			<h3>Ruby 1.9+</h3>
			
			<p>
				On peut directement utiliser la méthode <%= coderay({:inline => true}, "Method#source_location") %>, qui renverra le fichier où est défini votre méthode, et la ligne. Mais on doit d'abord récupérer une instance de <%= coderay({:inline => true}, "Method") %>. Pour ça, c'est la méthode <%= coderay({:inline => true}, "Object#method") %> qui va nous servir.<br/>
				Il faudra faire attention à une chose, la méthode <%= coderay({:inline => true}, "Method#source_location") %> renverra <%= coderay({:inline => true}, "nil") %> si la méthode cherchée n'est pas écrire en ruby.
			</p>
			
			<%= coderay do %>
class User
	def name
		"thomas"
	end
end

?> user = User.new

?> method = user.method(:name)
=> #<Method: User#name>

?> method.source_location
=> ["(irb)", 17]


# ---
?> "bonjour".method(:constantize).source_location
=> ["/opt/boxen/(...)/active_support/core_ext/string/inflections.rb", 53]


# --- Méthode native
?> "bonjour".method(:upcase).source_location
=> nil
			<% end %>
			
			<h3>Ruby 1.8 REE</h3>
			
			<p>
				Sur ruby 1.8, la méthode <%= coderay({:inline => true}, "Method#source_location") %> n'existe pas. Cependant, la version enterprise (ree) nous fournit deux méthodes, <%= coderay({:inline => true}, "__file__") %> et <%= coderay({:inline => true}, "__line__") %>, qui vont nous permettre de facilement reproduire le comportement de <%= coderay({:inline => true}, "Method#source_location") %>.
			</p>
			
			<%= coderay do %>
class Method
	def source_location
		[
			__file__,
			__line__
		]
	end
end

?> "bonjour".method(:constantize).source_location
=> ["/usr/local/rvm/(...)/active_support/core_ext/string/inflections.rb", 53]


# --- Méthode native
?> "bonjour".method(:upcase).source_location
=> ArgumentError: native Method
	from (irb):36:in `__file__'
	from (irb):36:in `source_location'
	from (irb):42
			<% end %>
			
			<h3>Conclusion</h3>
			
			<p>
				Voilà une méthode utile, pour du débug ou par curiosité, mais que je ne conseille de ne pas utiliser ailleurs que dans son irb ou sa console.
			</p>
			
			<p>
				Hop, c'est fini.
			</p>
			
		<% end %>
	<% end %>
<% end %>


