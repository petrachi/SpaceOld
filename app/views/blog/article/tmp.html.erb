<%= container do %>
	<%= row do %>
		<%= three_span :element => :sidebar do %>
			1
		<% end %>

		<%= nine_span :element => :article do %>
			
			
			<%= @article.title %>
			<%= @article.link %>
			<%= @article.label %>
			<%= @article.path %>
			<%= @article.scss %>
			
			<hr/>
			
			<%= decorate Blog::Article.last do |article| %>
				<%= article.title %>
				<%= article.link %>
				<%= article.label %>
				<%= article.path %>
				<%= article.scss %>
			<% end %>
			
			<hr/>
			<hr/>
			<hr/>
			
			
			
			<i>On prend deux couleurs, on les mixe, et on obtient en général quelque chose de tout à fait dégueulasse. Mais pas tout le temps.</i>
			
			<h2>Color Blender</h2>
			
			<p>
				Salut les p'tit amis,<br/>
				Donc le principe ici sera de faire une fonction permettant d'assurer une transition fluide entre deux couleurs.
			</p>
			
			<h3>Format de couleur</h3>
			
			<p>
				En gros, il y a deux formats de couleurs classiques utilisés en développement informatique.<br/>
				Le format hexadécimal, où le blanc est représenté comme ceci #ffffff, et le rouge utilisé pour les boutons de ce site #b62b2b. Ou le format rgv (pour touge, vert, bleu), où le blanc fait rgb(255, 255, 255), et le rouge des boutons fait rbg(182, 43, 43).<br/>
				On peut également trouver un format hsv, pour teinte, saturation et luminosité. Mais je crois que ce format est plus souvent utilisé en photo montage qu'en programmation.
			</p>
			
			<p>
				Nous allons devoir manipuler des couleurs dans notre petit algorithme, il faut donc choisir le format le plus approprié. J'ai choisi de travailler avec le format rgb, car utiliser les valeurs numériques sont plus faciles à manipuler. Le résultat attendu devra par contre être exprimé en hexa, car ce format est plus lisible.<br/>
				À la réflexion, manipuler les couleurs avec le format hsv aurait peut-être simplifié la tâche, ar ils sépare bien toute les composantes d'une couleur, et permet donc de trouver facilement une transition fluide.
			</p>
			
			<%= coderay do %>
def hex_to_rgb hex
	hex =~ /#(..)(..)(..)/
	{r: $1.hex, v: $2.hex, b: $3.hex}
end

def rgb_to_hex rgb
	"##{"%02x" % rgb[:r]}#{"%02x" % rgb[:v]}#{"%02x" % rgb[:b]}"
end
			<% end %>
			
			<h3>Color diff + color blend</h3>
			
			<p>
				Maintenant, on va devoir apprendre à m'langer deux couleurs. Pour ça, on calculera d'abord les valeurs de différences entre les deux couleurs. C'est relativement simple.
			</p>
			
			<%= coderay do %>
def diff_color from, to
	{
		r: to[:r] - from[:r],
		v: to[:v] - from[:v],
		b: to[:b] - from[:b]
	}
end
			<% end %>
			
			<p>
				Ensuite, nous allons appliquer cette différence à partir de la couleur de base, accouplé à un pourcentage de transformation.
			</p>
			
			<%= coderay do %>
def blend_color from, diff, progress
	{
		r: from[:r] + diff[:r] * progress,
		v: from[:v] + diff[:v] * progress,
		b: from[:b] + diff[:b] * progress
	}
end
			<% end %>
			
			<h3>Réunification de toutes les composantes</h3>
			
			<p>
				Nous pouvons maintenant réunir toutes les différentes étapes de notre blender. De la conversion rgb/hex, au calcul de la différence et à la transition lente d'une couleur à l'autre.
			</p>
			
			<%= coderay do %>
def blender from, to, steps
	blender = Array.new

	from = hex_to_rgb color_stops.shift
	to = hex_to_rgb color_stops.first

	diff = diff_color from, to

	steps.times do |i|
		progress = percent i, steps

		blended = blend_color from, diff, progress

		p "progress #{progress} - #{blended}"

		blender << rgb_to_hex(blended)
	end

	blender
end
			<% end %>
			
			<p>
				Si on fait un test rapide avec <%= coderay({:inline => true}, "blender('#b62b2b', '#2b2bb6', 186)") %>
			</p>
			
			<%= erb Blog::Experience.tagged(:color_clock).run(:only_blender) %>
			
			<h3>Color stops</h3>
			
			<p>
				Avant de conclure, je vous présente juste une petite amélioration qui permettra de chainer les appels à l'ancien blender. L'appel ressemblera à <%= coderay({:inline => true}, "blender(['#000000', '#ff00ff', '#ffffff'], 4)") %>.
			</p>
			
			<%= coderay do %>
def blender color_stops, steps
	blender = Array.new

	begin
		from = hex_to_rgb color_stops.shift
		to = hex_to_rgb color_stops.first

		diff = diff_color from, to

		steps.times do |i|
			progress = percent i, steps

			blended = blend_color from, diff, progress

			p "progress #{progress} - #{blended}"

			blender << rgb_to_hex(blended)
		end
	end while color_stops.size > 1

	blender
end
			<% end %>
			
			<h3>Conclusion</h3>
			
			<p>
				Voilà, un color blender très simple et rapidement réalisé. On pourrait améliorer largement cette fonction, pour inclure la transparence d'abord. Puis améliorer la gestion des <%= coderay({:inline => true}, "color_stops") %>, qui est très statique aujourd'hui.
			</p>
			
			<p>
				En dehors de ces améliorations possibles, l'algorithme fonctionne suffisamment bien. Je l'ai mis en place pour l'expérience du "color clock", et il remplit son rôle. J'avais commencé par le faire en javascript, mais j'avoue être bien plus à l'aise en ruby.
			</p>
			
			<p>
				Allez, bisous bisous, c'est la fin.
			</p>
			
			
			
			
			
			<hr/>
			
			<i>Pourquoi mon ordinateur ne comprends pas qu'il faut afficher "07" et pas "7". Rhaaa, ce genre de trucs me rends fou !</i>
			
			<h2>Pad with zero</h2>
			
			<p>
				Allez, pas de mensonges, on a tous été ennuyés par ce problème, ajouter des zéros au début d'un nombre afin de respecter un certain format. Ce que j'appelle dans le titre de cet article, pad with zero, je vais vous le raconter en deux langages. D'abord en javascript, et puis, le meilleur pour la fin, en ruby.
			</p>
			
			<h3>En Javascript</h3>
			
			<p>
				Voici une fonction simple, on prends une chaine de caratères composé uniquement de zéros et on y ajoute notre nombre. Ce porcéder permettra de "coller" les zéros devant notre nombre, il ne reste plus qu'à récupérer la longueur de chaine que nous voulions.
			</p>
			
			<%= coderay :lang => :javascript do %>
function pad(value, size) {
	var padded = "0000000000" + value;
	return padded.substr( padded.length - size )
}

> pad(15, 3);
"015"

> pad(155, 3);
"155"

> pad(1554, 3);
"554" // bug

> pad(1554, 15);
"4" // bug

// avec une valeur hexa
> pad("2bff", 6);
"002bff"
			<% end %>
			
			<p>
				Si cette fonction est utilisable dans la plupart des cas, il faut faire attention aux valeurs avec lesquelles on l'utilise, car elle possède un seuil de validité certain.
			</p>
			
			<h3>En Ruby</h3>
			
			<p>
				J'imagine qu'il y a de nombreuses autres façons de faire que celle que je vais vous présenter, mais j'aime vraiment la syntaxe un peu sale de l'utilisation du <%= coderay({:inline => true}, 'Kernel#sprintf') %>.
			</p>
			
			<%= coderay do %>
def pad value, size
	"%0#{ size }d" % value
end

?> pad 15, 3
=> "015"

?> pad 155, 3
=> "155"

?> pad 1554, 3
=> "1554"

?> pad 1554, 15
=> "000000000001554"

# avec une valeur hexa
> pad("2bff", 6);
ArgumentError: invalid value for Integer(): "f" # bug
			<% end %>
			
			<p>
				Et voilà ! Bon, la valeur hexa a bug, bah oui parceque le <%= coderay({:inline => true}, 'Kernel#sprintf') %> est un peu délicat avec les types. Mais si on voulait utiliser de l'hexa (ou du binaire), on pourrait le faire très simplment, et à partir de nombres décimaux.
			</p>
			
			<%= coderay do %>
# hexa
?> "%06x" % 15
=> "00000f"

# bin
?> "%08b" % 15
=> "00001111"
			<% end %>
			
			<h3>Conclusion</h3>
			
			<p>
				Bon, je l'avoue, la fonction javascript n'est pas de moi, et d'ailleurs je ne m'en suis presque jamais servie. Par contre, celle en ruby est de moi.
			</p>
			
			<p>
				La méthode <%= coderay({:inline => true}, 'Kernel#sprintf') %> est vraiment dure à aborder, et j'en ferais volontier un article si je la connaissait mieux. Elle est au moins aussi intéressante et moche que les regexp, mais comme on a vu, c'est une fonction assez puissante, et qui mériterais une part de soleil.
			</p>
			
			<p>
				C'est fini pour aujourd'hui. Allez, filez jouer dehors bande de petits sacripants.
			</p>
			
		<% end %>
	<% end %>
<% end %>


