<%= container do %>
	<%= row do %>
		<%= three_span :element => :sidebar do %>
			1
		<% end %>

		<%= nine_span :element => :article do %>
		
			<h2>Blocks</h2>
			
			<p>summary : <i>En ruby, les blocks permettent de définir un bout de code sans contexte, une fonction anonyme. Le dévellopeur rails en utilise fréquement dans des fonctions comme le 'each'. Nous allons voir comment les utiliser en paramètres de nos propres fonctions</i></p>
			
			<p>
				Un block (ou proc, ou lambda) c'est un bout de code, une fonction sans définition. Ils peuvent être utilisés pour passer du code en argument d'une fonction, et nous allons découvrir comment.
			</p>
			
			<h3>
				Les blocks comme on les connait
			</h3>
			
			<p>
				Seul un NulDeveloppeur en ruby/rails ne connaitrait pas les blocks, beaucoup de fonctions utilisent des blocks, <i>Array#each</i> pour n'en citer qu'une. Les blocks, c'est ce bout de code définit entre deux accolade à l'appel d'une fonction (note : les accolades peuvent aussi être troqués contre un do..end).
			</p>
		
			<h3>
				Écrire une fonction avec un block
			</h3>
		
			<p>
				Voici un exemple d'une fonction simple, qui utilise un block
			</p>
		
			<%= coderay :lang => :ruby do %>
	def simple
		p "Start of my very simple function"
		yield
		p "End of my very simple function"
	end

	?> simple{ p "I'm alive !" }
	=> "Start of my very simple function"
	"I'm alive !"
	"End of my very simple function"
			<% end %>
		
			<p>
				L'instruction <code>yield</code> <%= CodeRay.scan("yield", :ruby).span.html_safe %> indique à la fonction d'exécuter le code passé en paramètre, lors de l'appel.
			</p>
			
			<p>
				Notez que la syntaxe peut être plus explicite.
			</p>
			
			<%= coderay :lang => :ruby do %>
	def simple &block
		p "Start of my very simple function"
		block.call
		p "End of my very simple function"
	end

	?> simple{ p "I'm alive !" }
	=> "Start of my very simple function"
	"I'm alive !"
	"End of my very simple function"
			<% end %>
			
			<h3>
				Suite ... Développement de niveau 1
			</h3>
		
			<%= container do %>
	    		<%= row :nested => true do %>
		    		<%= four_span :append => 1 do %>
		    			<h4>Block optionnel - Tu fais quelque chose ou c'est moi !</h4>
						
		    			<%= coderay :lang => :ruby do %>
	def optional
		p "In my optionnal block function"
		if block_given?
			yield
		else
			p "No block given, so sad :("
		end
	end

	?> optional{ p "I'm alive" }
	=> "In my optionnal block function"
	"I'm alive"

	?> optional
	=> "In my optionnal block function"
	"No block given, so sad :("
						<% end %>
						
						<p>
							L'appel à <code>block_given?</code> permet de savoir si un block à été passé en paramètre à l'appel de la fonction.
						</p>
		      		<% end %>

			      	<%= four_span do %>
			      		<h4>Des paramètres au block</h4>

			      		<%= coderay :lang => :ruby do %>
	def parameters
		p "Here, have two random numbers."
		yield rand(10), rand(50)
		p "Now say thank you!"
	end

	?> parameters { |x, y| p "#{ x }, #{ y }" }
	=> "Here, have two random numbers."
	"8, 21"
	"Now say thank you!"
			   			<% end %>
						
						<p>
							Je donne à l'appel de la fonction des valeurs qui seront traitées dans le block, sans savoir ce que le développeur décidera d'en faire. C'est ici que ce joue la magie d'un <code>Array#each</code> par exemple.
						</p>
			   		<% end %>
			   	<% end %>
		  	<% end %>
		
			<h3>
				Boss de fin
			</h3>
	
			<%= coderay :lang => :ruby do %>
	def arity &block
		p "Arity function has begun"
		case block.arity
		when 1 then yield "one"
		when 2 then yield "one", "two"
		when 3 then yield "one", "two", "three"
		end
		p "Arity has ended"
	end

	?> arity{}
	=> "Arity function has begun"
	"Arity has ended"

	?> arity{ |x| p x }
	=> "Arity function has begun"
	"one"
	"Arity has ended"

	?> arity{ |x, y| p x, y }
	=> "Arity function has begun"
	"one"
	"two"
	"Arity has ended"

	?> arity{ |x, y, z| p x, y, z }
	=> "Arity function has begun"
	"one"
	"two"
	"three"
	"Arity has ended"
			<% end %>

			<p>
				La méthode <code>Proc#arity</code> permet de connaitre le nombre d'argument demandé lors de l'appel. Vous pourrez adapter le code de votre fonction afin de permettre différentes utilisations (utiliser un <code>Array</code> ou un <code>Hash</code> par exemple)
			</p>
		
			<h3>
				IRL
			</h3>
		
			<p>
				Et dans la vraie vie ? On utilise les blocks souvent lorsqu'il s'agit de fonction d'itération (Array#each) ou de templating (link_to, content_tag)
			</p>
			
			<%= container do %>
	    		<%= row :nested => true do %>
		    		<%= four_span :append => 1 do %>
						<h3>
							Un itérateur inutile
						</h3>
						
						<%= coderay :lang => :ruby do %>
	class Array
		def each_but_not_all range
			range.each do |i|
				yield self[i]
			end
		end
	end

	?> array = [1, 2, 3, 4, 5]
	=> [1, 2, 3, 4, 5]

	?> array.each_but_not_all (1..3) { |x| p x }
	=> 2
	3
	4
						<% end %>
					<% end %>
					
					<%= four_span do %>
						<h3>
							Une template inutile
						</h3>
						
						<p>
							<%= coderay :lang => :ruby do %>
					def my_box_tag &block
						"<div>" << yield << "</div>"
					end
							<% end %>
						</p>
					<% end %>
				<% end %>
			<% end %>
			
		
			<h3>
				Conclusion
			</h3>
		
			<p>
				Les blocks peuvent être très utile lorsque vous cherchez à rendre votre code plus modulable, à condition de penser à les utiliser ;)
			</p>
			
			<p>
				Bisous les copains !
			</p>
			
			
			<hr/>
			
			<h2>Positionnement relatif d'un sprite</h2>
			
			<p>summary : <i>Le positionnement dans un sprite (cette technique CSS qui permet de condenser toutes ses images dans un seul fichier)</i> est souvent exprimé en 'px', mais nous pouvons améliorer la flexibilité des sprites en utilisant un positionnement en '%'</p>
			
			<p>
				Prérequis pour une lecture sereine : connaitre Sass, Compass et la technique des sprites.
			</p>
			for me : mettre sass et compass en 'ressources'
			<p>
				Sass, allié avec Compass permettent facilement de créer et d'utiliser les sprites dans votre appli web, mais, avec l'émergence des icon-font (RTFMN - ici lien vers font-awesome), la rigidité du modéle des sprites me dérange.
			</p>
			
			<p>
				Nous ne pouvons pas agir simplement sur les propriétés des texte, via le CSS, d'une image géré en sprite, à l'inverse de ce que permet une icon-font. Mais je vous propose une technique qui permettra de se débarrasser de la contrainte de taille des images d'un sprite.
			</p>
			
			<h3>
				Création d'un sprite
			</h3>
			
			<p>
				Je vous laisse lire la doc (mettre lien vers doc sprite de compass) mais voici le code le plus simple qui permet de créer un sprite avec Compass
			</p>
			
			for me : mettre code sprite simple
			
			
			for me : mettre code css pour une image dans le sprite
			
			
			<p>
				Le code CSS généré utilise des valeurs en pixels pour le positionnement et la taille du background. Ce qui pose de légers problémes si je m'aventure à changer les propri!tés de taille de l'émément. (for me : link to expériment '4 tailles de sprite' en mode 'px')
			</p>
			
			<h3>
				Repositionnement relatif
			</h3>
			
			<p>
				Imaginons que le positionnement soit exprimé en '%', et que la largeur du sprite soit égale à 100% de la largeur de l'élément, alors, à condition de respecter les proportions, nous serions en mesure d'imposer n'importe quelle taille à nos images spritées.
			</p>
			
			<p>
				Attention ! Pour pouvoir utiliser cette technique sans risques, il faut que la taille (hauteur et largeur) des images du sprite soient identiques !
			</p>
			
			
			
			la suite : mixin re-positionnement sprite
			apparté : extend ruby d'une fonction sass
			suite : fin du mixin repo
			démo : experiment working
			conclusion
		<% end %>
	<% end %>
<% end %>
