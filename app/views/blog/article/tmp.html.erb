<%= container do %>
	<%= row do %>
		<%= three_span :element => :sidebar do %>
			1
		<% end %>

		<%= nine_span :element => :article do %>
			
			
			<%= @article.title %>
			
			<hr/>
			
			<%= decorate Blog::Article.last do |article| %>
				<%= article.title %>
			<% end %>
			
			<hr/>
			<hr/>
			<hr/>
			
			
			
			<i>On prend deux couleurs, on les mixe, et on obtient un dégradé parfaitement génial, avec du code tout à fait dégueulasse.</i>
			
			<h2>Color Blender</h2>
			
			<p>
				Salut les p'tit amis,<br/>
				Donc le principe ici sera de faire une fonction permettant d'assurer une transition fluide entre deux couleurs.
			</p>
			
			<h3>Format de couleur</h3>
			
			<p>
				En gros, il y a deux formats de couleurs classiques utilisés en développement informatique.<br/>
				Le format hexadécimal, où le blanc est représenté comme ceci #ffffff, et le rouge utilisé pour les boutons de ce site #b62b2b. Ou le format rgv (pour touge, vert, bleu), où le blanc fait rgb(255, 255, 255), et le rouge des boutons fait rbg(182, 43, 43).<br/>
				On peut également trouver un format hsv, pour teinte, saturation et luminosité. Mais je crois que ce format est plus souvent utilisé en photo montage qu'en programmation.
			</p>
			
			<p>
				Nous allons devoir manipuler des couleurs dans notre petit algorithme, il faut donc choisir le format le plus approprié. J'ai choisi de travailler avec le format rgb, car utiliser les valeurs numériques sont plus faciles à manipuler. Le résultat attendu devra par contre être exprimé en hexa, car ce format est plus lisible.<br/>
				À la réflexion, manipuler les couleurs avec le format hsv aurait peut-être simplifié la tâche, ar ils sépare bien toute les composantes d'une couleur, et permet donc de trouver facilement une transition fluide.
			</p>
			
			<%= coderay do %>
def hex_to_rgb hex
	hex =~ /#(..)(..)(..)/
	{r: $1.hex, v: $2.hex, b: $3.hex}
end

def rgb_to_hex rgb
	"##{"%02x" % rgb[:r]}#{"%02x" % rgb[:v]}#{"%02x" % rgb[:b]}"
end
			<% end %>
			
			<h3>Color diff + color blend</h3>
			
			<p>
				Maintenant, on va devoir apprendre à m'langer deux couleurs. Pour ça, on calculera d'abord les valeurs de différences entre les deux couleurs. C'est relativement simple.
			</p>
			
			<%= coderay do %>
def diff_color from, to
	{
		r: to[:r] - from[:r],
		v: to[:v] - from[:v],
		b: to[:b] - from[:b]
	}
end
			<% end %>
			
			<p>
				Ensuite, nous allons appliquer cette différence à partir de la couleur de base, accouplé à un pourcentage de transformation.
			</p>
			
			<%= coderay do %>
def blend_color from, diff, progress
	{
		r: from[:r] + diff[:r] * progress,
		v: from[:v] + diff[:v] * progress,
		b: from[:b] + diff[:b] * progress
	}
end
			<% end %>
			
			<h3>Réunification de toutes les composantes</h3>
			
			<p>
				Nous pouvons maintenant réunir toutes les différentes étapes de notre blender. De la conversion rgb/hex, au calcul de la différence et à la transition lente d'une couleur à l'autre.
			</p>
			
			<%= coderay do %>
def blender from, to, steps
	blender = Array.new

	from = hex_to_rgb color_stops.shift
	to = hex_to_rgb color_stops.first

	diff = diff_color from, to

	steps.times do |i|
		progress = percent i, steps

		blended = blend_color from, diff, progress
		blender << rgb_to_hex(blended)
	end

	blender
end
			<% end %>
			
			<p>
				Si on fait un test rapide avec <%= coderay({:inline => true}, "blender '#b62b2b', '#b5702b', 168") %>
			</p>
			
			<%= erb Blog::Experience.tagged(:color_clock).run(:only_blender) %>
			
			<h3>Color stops</h3>
			
			<p>
				Avant de conclure, je vous présente juste une petite amélioration qui permettra de chainer les appels à l'ancien blender.
			</p>
			
			<%= coderay do %>
def blender color_stops, steps
	blender = Array.new

	begin
		from = hex_to_rgb color_stops.shift
		to = hex_to_rgb color_stops.first

		diff = diff_color from, to

		steps.times do |i|
			progress = percent i, steps

			blended = blend_color from, diff, progress

			p "progress #{progress} - #{blended}"

			blender << rgb_to_hex(blended)
		end
	end while color_stops.size > 1

	blender
end
			<% end %>
			
			<p><%= coderay({:inline => true}, "blender %w(#063186 #A21111 #D3A80D #28A528), 56") %></p>
			
			<%= erb Blog::Experience.tagged(:color_clock).run(:multiple_blender) %>
			
			<h3>Conclusion</h3>
			
			<p>
				Voilà, un color blender très simple et rapidement réalisé. On pourrait améliorer largement cette fonction, pour inclure la transparence d'abord. Puis améliorer la gestion des <%= coderay({:inline => true}, "color_stops") %>, qui est très statique aujourd'hui.
			</p>
			
			<p>
				En dehors de ces améliorations possibles, l'algorithme fonctionne suffisamment bien. Je l'ai mis en place pour l'expérience du "color clock", et il remplit son rôle. J'avais commencé par le faire en javascript, mais j'avoue être bien plus à l'aise en ruby.
			</p>
			
			<p>
				Allez, bisous. Filez jouer maintenant !
			</p>
			
			
			
			
			
			
			
			
			
			
			<hr/>
			<hr/>
			<hr/>
			<hr/>
			<hr/>
			<hr/>
			<hr/>
			<hr/>
			<hr/>
			<hr/>
			<hr/>
			<hr/>
			
			<i>Pourquoi mon ordinateur ne comprends pas qu'il faut afficher "07" et pas "7". Rhaaa, ce genre de trucs me rend fou !</i>
			
			<h2>Pad with zeros</h2>
			
			<p>
				Allez, pas de mensonges, on a tous eu besoin d'ajouter des zéros au début d'un nombre afin de respecter un certain format. Aujourd'hui, je vous donne la solution dans deux languages. Enjoy ;)
			</p>
			
			<h3>En Javascript</h3>
			
			<p>
				Donc, on va prendre une chaine de caractère composée uniquement de zéros, ajouter à la suite notre nombre, et enfin, on va sélectionner dans cette nouvelle chaine le nombre correcte de caractères. Si la fonction renvoie le plus souvent un résultat correct, elle va renvoyer une mauvaise valeur si je veux injecter trop de zéros, ou si le nombre passé en paramètre est trop grand.
			</p>
			
			<%= coderay :lang => :javascript do %>
function pad(value, size) {
	var padded = "0000000000" + value;
	return padded.substr(padded.length - size);
}

> pad(15, 3);
"015"

> pad(155, 3);
"155"

> pad(1554, 3);
"554" // ! bug

> pad(1554, 15);
"4" // ! bug

> pad("2bff", 6); // hexa
"002bff"
			<% end %>
			
			<h3>En Ruby</h3>
			
			<p>
				Il y a peut-être de meilleures façon de faire, mais personnellement j'utilise la méthode <%= coderay({:inline => true}, 'Kernel#sprintf') %>. Si la syntaxe de est au moins aussi sale que celle des <%= coderay({:inline => true}, 'Regexp') %>, la méthode est vraiment puissante et permet de formatter une string facilement.
			</p>
			
			<p>
				Je vais pas vous refaire la doc, mais juste une petite explication. On crée une <%= coderay({:inline => true}, 'String') %> qui correspond au format voulu, on utilise ensuite l'opérateur <%= coderay({:inline => true}, '%') %> qui peut prendre en paramètre au choix, un <%= coderay({:inline => true}, 'Array') %> ou un <%= coderay({:inline => true}, 'Hash') %>. La <%= coderay({:inline => true}, 'String') %> de format va utiliser certains caractères spéciaux afin d'insérer les paramètres. Ici pourra utiliser <%= coderay({:inline => true}, '"%02d"') %>, ce qui veut dire <i>insère le premier paramètre , dont le type doit pouvoir être caster via <%= coderay({:inline => true}, 'Integer()') %>, et ajouter des zéros au besoin pour atteindre une longueur minimale de 2</i>.
			</p>
			
			<%= coderay do %>
def pad value, size
	"%0#{ size }d" % value
end

?> pad 15, 3
=> "015"

?> pad 155, 3
=> "155"

?> pad 1554, 3
=> "1554"

?> pad 1554, 15
=> "000000000001554"

> pad("2bff", 6); # hexa
ArgumentError: invalid value for Integer(): "f" # ! bug
			<% end %>
			
			<p>
				La méthode fonctionne bien, on ne retrouve pas les problèmes qu'on avait rencontré en javascript, par contre cette méthode est beaucoup plus sensible aux types des paramètres que l'on utilise. On se rendra compte en lisant la doc plus attentivement qu'utiliser une valeur en hexadécimal, voire en binaire, est aussi possible. Et facilement encore une fois, la méthode se chargera de la conversion des valeurs !
			</p>
			
			<%= coderay do %>
?> "%06x" % 15 # hexa
=> "00000f"

?> "%08b" % 15 # binaire
=> "00001111"
			<% end %>
			
			<h3>Conclusion</h3>
			
			<p>
				<%= coderay({:inline => true, :lang => :html}, '<troll>ruby > javascript</troll>') %>
			</p>
			
			<p>
				La méthode <%= coderay({:inline => true}, 'Kernel#sprintf') %> est assez repoussante la première fois, mais elle se révèle suffisamment puissante pour qu'on l'utilise quand même. Ça me fait beaucoup penser au <%= coderay({:inline => true}, 'Regexp') %> sur cette idée, je l'aime et la déteste tout en même temps.
			</p>
			
			<p>
				C'est fini pour aujourd'hui. Allez, tu vas pas rester toute la journée devant ton écran alors qu'il fait beau ?
			</p>
			
		<% end %>
	<% end %>
<% end %>


