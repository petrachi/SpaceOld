<%= container do %>
	<%= row do %>
		<%= three_span :element => :sidebar do %>
			1
		<% end %>

		<%= nine_span :element => :article do %>
			
			
			
			<h2>Gaulois cherche Gauloise</h2>
			
			<em>
				Chez les gaulois, l'amour triomphe toujours ! Comment ça se passe en ruby ? C'est justement le sujet de cet article.
			</em>
			
			<h2>Gaulois cherche Gauloise</h2>
			
			<p>
				Salut les p'tit amis.<br/>
				Aujourd'hui, un programme simple avec un gaulois, qui tentera de rejoindre sa gauloise. On va d'abord créer une carte, y placer nos deux personnages, et faire bouger notre gaulois jusqu'à ce qu'il rejoigne sa chérie. Tout ça grâce à la puissance et à la beauté de ruby !
			</p>
			
			<h3>'M' pour afficher la carte</h3>
			
			<p>
				Pour représenter la carte du monde, on va d'abord créer une classe <%= coderay({:inline => true}, "Province") %>, qui représentera une position sur la carte. Puis une classe <%= coderay({:inline => true}, "World") %>, qui regroupera toutes les provinces.
			</p>
			
			<p>
				On veut créer une carte où les positions sont des hexagones. Pourquoi des hexagones et pas des carrés ? Simplement parce qu'ils représentent mieux la réalité. Lorsqu'on choisis de représenter une carte à partir d'une série de position, comme ici, il est important d'anticiper la notion de distance entre deux positions.<br/>
				On aurait plus naturellement choisi des positions carrés, pour représenter la carte comme un grand tableau. Le problème qui se pose, si on définit une distance de 1 pour deux provinces côtes à côtes, est de calculer la distance d'une position en diagonale. Une distance qui ne soit pas un entier va nous poser problème ensuite. Ce problème ne se posera pas avec des positions hexagonales.
			</p>
			
			<p>
				Les positions seront définies par trois coordonnées. Encore une fois, il semble plus naturel de n'utiliser que deux coordonnées pour représenter une carte en 2D, mais ajouter une troisième coordonnées permettra de faciliter largement le calcul des distances entre deux positions. Ces trois coordonnées seront notés <%= coderay({:inline => true}, ":x, :y, :z") %>, et devront respecter la condition <%= coderay({:inline => true}, "-x + y + z == 0") %>.
			</p>
			
			<p>
				Sans plus attendre, je vous donne le code de nos deux premières classes.
			</p>
			
			<%= coderay do %>
class World
	attr_accessor :provinces

	def initialize size
		@provinces = Array.new

		(-size..size).each do |x|
			(-size..size).each do |y|
				@provinces << Province.new(x, y, (x - y))
			end
		end
	end
end

class Province
	attr_accessor :x, :y, :z

	def initialize x, y, z
		@x, @y, @z = x, y, z
	end
end
			<% end %>
			
			<p>
				Rapidement, on va afficher un exemple de la liste des positions générées.
			</p>
			
			<%= coderay do %>
class World
	def show
		@provinces.map do |province|
			province.show
		end
	end
end

class Province
	def show
		[@x, @y, @z]
	end
end


?> world = World.new 2
?> world.show
=> [
	[-1, -1, 0], 
	[-1, 0, -1], 
	[-1, 1, -2], 
	[0, -1, 1], 
	[0, 0, 0], 
	[0, 1, -1], 
	[1, -1, 2], 
	[1, 0, 1], 
	[1, 1, 0]
]
			<% end %>
			
			<h3>Les Gaulois</h3>
			
			<p>
				Pour représente nos deux gaulois, rien de plus simple, on va créer une classe <%= coderay({:inline => true}, "Gaulois") %>, et lui donner un attribut <%= coderay({:inline => true}, ":province") %>. On va en profiter pour créer et placer les deux personnages dans la méthode <%= coderay({:inline => true}, "World#initialize") %>.
			</p>
			
			<%= coderay do %>
class Gaulois
	attr_accessor :province

	def initialize province
		@province = province
	end

	def show
		@province.show
	end
end
			
			
class World
	attr_accessor :provinces, :gaulois, :gauloise

	def initialize size
		@provinces = Array.new

		(-size..size).each do |x|
			(-size..size).each do |y|
				@provinces << Province.new(x, y, (x - y))
			end
		end
		
		@gaulois = Gaulois.new(self, @provinces.sample)
	    @gauloise = Gaulois.new(self, (@provinces.except(@gaulois.province)).sample)
	end
end
			
			<% end %>
			
			<p>
				Rapide digression, j'ai crée deux méthodes : <%= coderay({:inline => true}, "Array#except") %> et <%= coderay({:inline => true}, "Array#sample") %>. La première exclu une, ou plusieurs, valeurs dans un tableau. La seconde sélectionne une valeur aléatoirement.<br/>
				Ces deux extends ne sontpas obligatoires, vous trouverez <%= coderay({:inline => true}, "Array#reject") %> e ruby, qui fait presque la même chose que mon <%= coderay({:inline => true}, "Array#except") %>. Et <%= coderay({:inline => true}, "Array#sample") %> est déjà inclus dans rails, puisque la méthode est définie dans <%= coderay({:inline => true}, "??? active support") %>.
			</p>
			
			<%= coderay do %>
class Array
	def except *value
		self - [*value]
	end

	def sample
		shuffle.first
	end
end
			<% end %>
			
			<h3>Conclusion</h3>
			
			<p>
				Allez, on a fait un monde et deux gaulois, je pense qu'il est temps de se reposer. C'est déjà beaucoup. Un prochain article va suivre où on commencera à faire bouger notre gaulois.
			</p>
			
			
			
			
			<hr/>
			
			<em>
				On va se bouger aujourd'hui ! Et le gaulois aussi, ça suffit !
			</em>
			
			<h2>Gaulois cherche gauloise (part 2)</h2>
			
			<p>
				Coucou les copains, comment ça va aujourd'hui ?<br/>
				Allez directement, on a fait un monde, des provinces, des gaulois, maintenant il faut les faire se déplacer. Sauf la gauloise, elle, elle bouge pas.
			</p>
			
			<h3>Du mouvement vint la vie</h3>
			
			<p>
				Pour faire déplacer Gérôme le gaulois, il suffit de modifier la valeur de l'attribut <%= coderay({:inline => true}, ":province") %>. La difficulté sera de sélectionner une valeur cohérente. Pour cela, nous allons créer une méthode <%= coderay({:inline => true}, "Province#vision(distance)") %>, qui nous renverra la liste de toutes les provinces visibles à une certaine distance. Et une méthode <%= coderay({:inline => true}, "Province#distance(province)") %>, qui va calculer la distance jusqu'à la province passé en paramètre.
			</p>
			
			<p>
				Afin d'avoir accès aux provinces qui existent dans le monde, nous allons devoir modifer la méthode <%= coderay({:inline => true}, "Province#initialize") %>, pour passer l'instance de la classe <%= coderay({:inline => true}, "World") %> dans laquelle elle est incluse.
			</p>
			
			<%= coderay do %>
class Province
	attr_accessor :x, :y, :z

	def initialize x, y, z, world
		@x, @y, @z, @world = x, y, z, world
	end

	def vision distance
		@world.provinces.select do |province|
			(@x - distance..@x + distance) === province.x and
			(@y - distance..@y + distance) === province.y and
			(@z - distance..@z + distance) === province.z
		end
	end
end


class World
	attr_accessor :provinces, :gaulois, :gauloise

	def initialize size
		@provinces = Array.new

		(-size..size).each do |x|
			(-size..size).each do |y|
				@provinces << Province.new(x, y, (x - y), self)
			end
		end

		@gaulois = Gaulois.new(self, @provinces.sample)
		@gauloise = Gaulois.new(self, (@provinces.except(@gaulois.province)).sample)
	end
end
			<% end %>
			
			<h3>Gaulois#move</h3>
			
			<p>
				Enfin, on va pouvoir faire se déplacer notre Gérôme le gaulois. À chaque "tour" (<%= coderay({:inline => true}, "World#play_turn") %>), il va regarder toutes les provinces autour de lui, à une distance de 1, et se déplacer sur l'une d'entre-elles aléatoirement (<%= coderay({:inline => true}, "Gaulois#move") %>). On répétera l'opération jusqu'a ce que les deux personnages soit réunis.
			</p>
			
			<%= coderay do %>
class Gaulois
	def move
		province = @province.vision(1).except(@province)
		@province = province
	end
end


class World
	def play_turn
		@gaulois.move
	end
end
			<% end %>
			
			<p>
				Volontairement, je vais choisir un monde assez petit. Ainsi codé, Gérôme le gaulois peut lobotomiser assez longtemps avant de retrouver sa gauloise.
			</p>
			
			<%= coderay do %>		
?> world = World.new 2
puts "Gauloise stands on #{ world.gauloise.province.show.inspect }"

begin
	puts "Gaulois stands on #{ world.gaulois.province.show.inspect }"
	world.play_turn
end until world.gaulois.province == world.gauloise.province

puts "L'amour triomphe toujours chez les gaulois ! Gaulois has reach #{ world.gaulois.province.show.inspect }"

=> "Gauloise stands on [2, -1, 3]"
"Gaulois stands on [0, 1, -1]"
"Gaulois stands on [-1, 0, -1]"
"Gaulois stands on [-2, -1, -1]"
"Gaulois stands on [-1, 0, -1]"
"Gaulois stands on [0, 0, 0]"
"Gaulois stands on [1, 0, 1]"
"Gaulois stands on [1, -1, 2]"
"Gaulois stands on [0, -1, 1]"
"Gaulois stands on [1, 0, 1]"
"Gaulois stands on [2, 0, 2]"
"L'amour triomphe toujours chez les gaulois ! Gaulois has reach [2, -1, 3]"
			<% end %>

			<h3>Conclusion</h3>
			
			<p>
				Et voilà ! L'amour à triomphé ! C'est très bien. Dans le prochain et dernier article, on va améliorer la méthode <%= coderay({:inline => true}, "Gaulois#move") %>, pour que les déplacements soit un peu moins aléatoires.
			</p>
			
			<p>
				Allez, c'est tout pour aujourd'hui. Vous pouvez partir. Il faut me débarrasser le plancher !
			</p>
			
			
			
			<hr/>
			
			<em>
				Épisode final où l'amour triomphe pour Gérôme le gaulois et sa copine. Aujourd'hui, on fait de l'intelligence artificielle ! (Enfin, pas vraiment mais on va dire que oui).
			</em>
			
			<h2>Gaulois cherche gauloise (part 3)</h2>
			
			
			<p>
				En forme aujourd'hui ?<br/>
				Très bien. Retour sur nos deux gaulois. Dans cet épisode final, on va upgrade la méthode <%= coderay({:inline => true}, "Gaulois#move") %> de deux façons, vous allez voir, vous allez comprendre.
			</p>
			
			<h3>Vision de jeu</h3>
			
			<p>
				On va ajouter un attribut <%= coderay({:inline => true}, ":vision") %> à la classe <%= coderay({:inline => true}, "Gaulois") %>. Ce nouvel attribut nous permettra d'inspecter les alentours avant de se déplacer.
			</p>
			
			<p>
				Rappelez vous, dans la méthode <%= coderay({:inline => true}, "Gaulois#move") %>, on sélectionne une province sur laquelle se déplacer. Pour l'instant, le choix de la province reléve du pur hasard. On va modifier la méthode afin de regarder d'abord si la gauloise que nous cherchons à atteindre est en vue. Si oui, nous sélectionnerons une province qui nous rapproche d'elle le plus possible. Sinon, on retourne sur le hasard.
			</p>
			
			<%= coderay do %>
class Gaulois
	attr_accessor :world, :province

	def initialize world, province
		@world, @province = world, province
		@vision = 4
	end

	def find_a_way
		province_gauloise = look{ |province| province == @world.gauloise.province }
    
		if province_gauloise
			if province_gauloise.distance(@province) == 1
				province_gauloise
			else
				closest_distance = province_gauloise.distance(@province)
				closest_province = nil

				@province.vision(1).each do |province|
					if province_gauloise.distance(province) < closest_distance
						closest_province = province
						closest_distance = province_gauloise.distance(province)
					end
				end

				closest_province
			end
		else
			@province.vision(1).except(@province)
		end
	end
end

class World
	def play_turn
		province = @gaulois.find_a_way
		@gaulois.move(province)
	end
end
			<% end %>
			
			<h3>Mémoire - Du poisson rouge à l'éléphant</h3>
			
			<p>
				Pour finir, nous allons mémoriser toutes les provinces déjà visitées, et éviter d'y retourner. Pour faire ça, on va stocker toutes les provinces vues dans un tableau, et modifier la partie "sélection aléatoire" de la méthode <%= coderay({:inline => true}, "Gaulois#move") %>, afin d'exclure les provinces déjà visitées de la liste des déplacements disponibles. Il faudra également prévoir le cas où toutes les déplacements disponibles ont déjà été vus, pour éviter de se retrouver coincé dans un cul de sac.
			</p>
			
			<%= coderay do %>
class Gaulois
	def initialize world, province
		@world, @province = world, province
		@vision = 4

		@seen = Array.new
	end

	def move province
		@province = province
		@seen << @province
	end

	def find_a_way
		province_gauloise = look{ |province| province == @world.gauloise.province }
    
		if province_gauloise
			if province_gauloise.distance(@province) == 1
				province_gauloise
			else
				closest_distance = province_gauloise.distance(@province)
				closest_province = nil

				@province.vision(1).each do |province|
					if province_gauloise.distance(province) < closest_distance
						closest_province = province
						closest_distance = province_gauloise.distance(province)
					end
				end

				closest_province
			end
		else

			possible_provinces = @province.vision(1).except(@province).except(@seen)
			possible_provinces = @province.vision(1).except(@province) if possible_provinces.empty?
			possible_provinces.sample
		end
	end
end
			<% end %>
			
			<p>
				Avec ça, Gérôme le gaulois devrait retouver sa belle plus rapidement. Allez, je lance le script, et je vous rajoute des <%= coderay({:inline => true}, "puts") %> pour bien comprendre tout ce qui se passe.
			</p>
			
			<%= coderay do %>		
?> world = World.new 7
puts "Gauloise stands on #{ world.gauloise.province.show.inspect }"

begin
	world.play_turn
end until world.gaulois.province == world.gauloise.province

puts "L'amour triomphe toujours chez les gaulois ! Gaulois has reach #{ world.gaulois.province.show.inspect }"

=> "Gauloise stands on [5, -4, 9]"
"Exploring new path -> Gaulois stands on [6, 3, 3]"
"Exploring new path -> Gaulois stands on [6, 2, 4]"
"Gauloise is unreachable (distance : 5) -> Gaulois stands on [5, 1, 4]"
"Gauloise is unreachable (distance : 4) -> Gaulois stands on [5, 0, 5]"
"Gauloise is unreachable (distance : 3) -> Gaulois stands on [5, -1, 6]"
"Gauloise is unreachable (distance : 2) -> Gaulois stands on [5, -2, 7]"
"Gauloise is close -> Gaulois stands on [5, -3, 8]"
"L'amour triomphe toujours chez les gaulois ! Gaulois has reach [5, -4, 9]"
			<% end %>
			
			<p>
				Youpi, l'amour triomphe encore chez les gaulois ! C'était le dernier article de la série, même si on pourrait encore travailler à davantage d'améliorations. Si vous voulez vous amuser, je vous conseillerais d'ajouter des obstacles sur la route, par exemple.
			</p>
			
			<h3>Conclusion</h3>
			
			<p>
				J'ai surtout l'habitude de rails, et j'ai dû travailler sur la notion de "visibilité" des objets. Par exemple pour les provinces, j'aurais eu le réflexe de faire quelque chose comme <%= coderay({:inline => true}, "province.world.provinces") %>. Le système d'associations d'<%= coderay({:inline => true}, "ActiveRecord") %>, et le fait d'avoir une base de donnée, rends presque invisible les mécaniques qui vont lier deux objets entre eux. Comment faire alors pour qu'une instance de <%= coderay({:inline => true}, "Province") %> ait accès au reste de ses homologues ?
			</p>
			
			<p>
				Peut-être que cette première expérience en "plain ruby" m'amènera à me pencher d'avantage sur les mécaniques d'<%= coderay({:inline => true}, "ActiveRecord") %>, et de ruby sans rails.
			</p>
			
			<p>
				Allez, je vous laisse les copains. C'est fini pour aujourd'hui. Non mais allez-vous en, ça commence à devenir gênant.
			</p>
			
			
			<hr/>
			<hr/>
			<hr/>
			
			
			
			
			
			<%
				
					









				# eléments de base
				#normalement ouvert
				def switch_no p = true, *i
					{
						[false, false] => false,
						[false, true] => false,
						[true, false] => false,
						[true, true] => true
					}[[p, *i]]
				end
				
				#normalement closed
				def switch_nc p = true, *i 
					{
						[false, false] => false,
						[false, true] => false,
						[true, false] => true,
						[true, true] => false
					}[[p, *i]]
				end
				
				def split p = true
					{
						false => [false]*2
					}[p]
				end
				
				def combine *p
					p ||= Array.new 2, true
					
					{
						[false, false] => false,
						[false, true] => true,
						[true, false] => true,
						[true, true] => true
					}[p]
				end
				
				
				
				# portes logiques
				def yes p, i
					switch_no p, i
				end
				
				def no p, i
					switch_nc p, i
				end
				
				def d_and p, *i
					f = switch_no p, i[0]
					switch_no f, i[1]
				end
				
				def d_or p, *i
					f = Array.new 2
					
					f[0] = switch_no p, i[0]
					f[1] = switch_no p, i[1]
					combine *f
				end
				
				def not_and p, *i
					f = Array.new 2
					
					f[0] = switch_nc p, i[0]
					f[1] = switch_nc p, i[1]
					combine *f
				end
				
				def not_or p, *i
					f = switch_nc p, i[0]
					switch_nc f, i[1]
				end
				
				def xor p, *i
					f = Array.new 2
					
					f[0] = switch_nc p, i[0]
					f[0] = switch_no f[0], i[1]
					
					f[1] = switch_no p, i[0]
					f[1] = switch_nc f[1], i[1]
					
					combine *f
				end
				
				
				
				# additionneurs
				def half_adder *i
					f = Array.new 2
					
					o = xor true, *i
					r = d_and true, *i
					
					return o, r
				end
				
				def adder *i
					tmp_o, tmp_r1 = half_adder i[0], i[1]
					o, tmp_r2 = half_adder tmp_o, i[2]
					
					r = d_or true, tmp_r1, tmp_r2
					
					return o, r
				end
				
				def parallel_adder_4bit *i
					o = Array.new 4
					
					#premier nombre 4 bit == i[0..3]
					#second nombre 4 bit == i[4..7]
					#premiere retenue == i[8]
										
					o[3], r = adder i[3], i[7], i[8]
					o[2], r = adder i[2], i[6], r
					o[1], r = adder i[1], i[5], r
					o[0], r = adder i[0], i[4], r 
					
					return r, *o
				end
			%>
			
			
			<%
			#truc d'affichages
			def to_4bit i
				("%04d" % i.to_s(2)).split(//).map{ |x| x == "1" }
			end
			
			def from_4bit i
				i.map{|x| x ? "1" : "0"}.join.to_i(2)
			end
			%>
			
			<h3>or</h3>
			true true false false<br/>
			<%= d_or true, true, true %>
			<%= d_or true, true, false %>
			<%= d_or true, false, false %>
			<%= d_or false, true, true %>
			
			<hr/>
			
			<h3>half adder</h3>
			[false, false] [true, false] [false, true]<br/>
			<%= half_adder(false, false).inspect %>
			<%= half_adder(false, true).inspect %>
			<%= half_adder(true, true).inspect %>
			
			<hr/>
			
			<h3>adder</h3>
			[false, false] [true, false] [false, true] [true, false] [false, true] [true, true]<br/>
			<%= adder(false, false, false).inspect %>
			<%= adder(false, true, false).inspect %>
			<%= adder(true, true, false).inspect %>
			<%= adder(true, false, false).inspect %>
			<%= adder(true, false, true).inspect %>
			<%= adder(true, true, true).inspect %>
			
			<hr/>
			
			<h3>parallel adder 4bit</h3>
			<%	lookup = Hash.new{ |h, k| h[k] = to_4bit k }
				r_lookup = Hash.new{ |h, k| h[k] = from_4bit k }# need une fonction rfetch pour les hash -> idée pour r_extend
			
				setup_2 = (lookup[1] + lookup[1]).flatten << false
				setup_5 = (lookup[2] + lookup[3]).flatten << false
				setup_7 = (lookup[2] + lookup[5]).flatten << false
				setup_15 = (lookup[9] + lookup[6]).flatten << false
				setup_24 = (lookup[15] + lookup[9]).flatten << false
				setup_31 = (lookup[15] + lookup[15]).flatten << true
				
			%>
			
			2 5 7 15 24 31<br/>
			<%= r_lookup[parallel_adder_4bit(*setup_2)] %>
			<%= r_lookup[parallel_adder_4bit(*setup_5)] %>
			<%= r_lookup[parallel_adder_4bit(*setup_7)] %>
			<%= r_lookup[parallel_adder_4bit(*setup_15)] %>
			<%= r_lookup[parallel_adder_4bit(*setup_24)] %>
			<%= r_lookup[parallel_adder_4bit(*setup_31)] %>
			
			
			
			<hr/>
			<h1>Using class</h1>
			<hr/>
			
			<h3>parallel adder 4bit</h3>
			<%	lookup = Hash.new{ |h, k| h[k] = to_4bit k }
				r_lookup = Hash.new{ |h, k| h[k] = from_4bit k }# need une fonction rfetch pour les hash -> idée pour r_extend
			
				setup_2 = (lookup[1] + lookup[1]).flatten << false
				setup_5 = (lookup[2] + lookup[3]).flatten << false
				setup_7 = (lookup[2] + lookup[5]).flatten << false
				setup_15 = (lookup[9] + lookup[6]).flatten << false
				setup_24 = (lookup[15] + lookup[9]).flatten << false
				setup_31 = (lookup[15] + lookup[15]).flatten << true
				
			%>
			
			2 5 7 15 24 31<br/>
			<%#= r_lookup[Adder.new.parallel_adder_4bit(*setup_2)] %>
			<%#= r_lookup[Adder.new.parallel_adder_4bit(*setup_5)] %>
			<%#= r_lookup[Adder.new.parallel_adder_4bit(*setup_7)] %>
			<%#= r_lookup[Adder.new.parallel_adder_4bit(*setup_15)] %>
			<%#= r_lookup[Adder.new.parallel_adder_4bit(*setup_24)] %>
			<%#= r_lookup[Adder.new.parallel_adder_4bit(*setup_31)] %>
			
			
			
			
			
			
			
			
			
			
			
			
			
		<% end %>
	<% end %>
<% end %>


